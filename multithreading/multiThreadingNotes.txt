Executing several tasks simultaneously where each task is a separate independent part
of the same program, is called Thread based multitasking.
And each independent part is called a "Thread". 

We can define a Thread in the following 2 ways.
1. By extending Thread class.
2. By implementing Runnable interface.

If multiple Threads are waiting to execute then which Thread will execute 1st is
decided by "Thread Scheduler" which is part of JVM.
 Which algorithm or behavior followed by Thread Scheduler we can't expect
exactly it is the JVM vendor dependent hence in multithreading examples we
can't expect exact execution order and exact output.

start() vs run()
-----------------
In the case of t.start() a new Thread will be created which is responsible for the
execution of run() method.
 But in the case of t.run() no new Thread will be created and run() method will be
executed just like a normal method by the main Thread.

start() method
--------------
For every Thread the required mandatory activities like registering the Thread with
Thread Scheduler will takes care by Thread class start() method and programmer is
responsible just to define the job of the Thread inside run() method.
That is start() method acts as best assistant to the programmer.
Example:
start()
{
1. Register Thread with Thread Scheduler
2. All other mandatory low level activities.
3. Invoke or calling run() method.
}
We can conclude that without executing Thread class start() method there is no chance
of starting a new Thread in java. Due to this start() is considered as heart of
multithreading

---------------------------
override run() method?
It is highly recommended to override run() method. Otherwise don't go for
multithreading concept. 

-------------------------------
overload run() method?
We can overload run() method but Thread class start() method always invokes no
argument run() method the other overload run() methods we have to call explicitly then
only it will be executed just like normal method. 
----------------------------------
override start() method?
: It is never recommended to override start() method. 
------------------

1. extending thread class
Mythread -> Thread -> Runnable

2. implementing runnable interface
MyRunnable -> Runnable 


We can define a Thread even by implementing Runnable interface also.
Runnable interface present in java.lang.pkg and contains only one method run().

Best approach to define a Thread:
 Among the 2 ways of defining a Thread, implements Runnable approach is
always recommended.
 In the 1st approach our class should always extends Thread class there is no
chance of extending any other class hence we are missing the benefits of
inheritance.
 But in the 2nd approach while implementing Runnable interface we can extend
some other class also. Hence implements Runnable mechanism is recommended
to define a Thread.

------------
Getting and setting name of a Thread:
 Every Thread in java has some name it may be provided explicitly by the
programmer or automatically generated by JVM.
 Thread class defines the following methods to get and set name of a Thread.
Methods:
1. public final String getName()
2. public final void setName(String name)
-------------------

THREAD LIFE CYCLE
MyThread t = new MyThread();

thread object created -> new state
t.start()             -> ready/runnable state
if thread scheduler allocated -> running state
once run() completed -> dead state 

case: restart the thread again
After starting a Thread we are not allowed to restart the same Thread once again 
otherwise we will get runtime exception saying "IllegalThreadStateException". 

Thread Priorities 
-----------------
 Every Thread in java has some priority it may be default priority generated by 
JVM (or) explicitly provided by the programmer. 

 
 The valid range of Thread priorities is 1 to 10[but not 0 to 10] where 1 is the least 
priority and 10 is highest priority. 
 Thread class defines the following constants to represent some standard 
priorities.  
1. Thread. MIN_PRIORITY----------1 
2. Thread. MAX_PRIORITY----------10 
3. Thread. NORM_PRIORITY--------5 
 There are no constants like Thread.LOW_PRIORITY, 
Thread.HIGH_PRIORITY 
 Thread scheduler uses these priorities while allocating CPU. 
 The Thread which is having highest priority will get chance for 1st execution. 
 If 2 Threads having the same priority then we can't expect exact execution order 
it depends on Thread scheduler whose behavior is vendor dependent. 
 We can get and set the priority of a Thread by using the following methods.  
1. public final int getPriority() 
2. public final void setPriority(int newPriority);//the allowed values are 1 to 
10 
 The allowed values are 1 to 10 otherwise we will get runtime exception saying 
"IllegalArgumentException". 
Default priority: 
The default priority only for the main Thread is 5. But for all the remaining Threads 
the default priority will be inheriting from parent to child. That is whatever the priority 
parent has by default the same priority will be for the child also. 

The Methods to Prevent a Thread from Execution: 
-------------------------------------------------
 
We can prevent(stop) a Thread execution by using the following methods.  
1. yield(); 
2. join(); 
3. sleep(); 
yield(): 
----------
1. yield() method causes "to pause current executing Thread for giving the chance 
of remaining waiting Threads of same priority".

CASE 1
OTHER WAITING  THREAD - LOW PRIORITY   -> CURRENT THREAD CONTINUES ITS EXECUTION
NO WAITING THREAD  ->CURRENT THREAD CONTINUES ITS EXECUTION

CASE 2:
OTHER WAITING THREADS - SAME PRIORITY    ->WE CAN'T EXPECT WHICH THREAD WILL GET CHANCE 


current thread goes back to running state, based on the thread scheduler 



2.Join(): 
----------
If a Thread wants to wait until completing some other Thread then we should go for 
join() method.  
Example: If a Thread t1 executes t2.join() then t1 should go for waiting state until 
completing t2. 

Every join() method throws InterruptedException, which is checked exception hence 
compulsory we should handle either by try catch or by throws keyword. 
Otherwise we will get compiletime error. 

t1,t2 

t1 -> t2.join()


DEADLOCK SCENARIO: https://github.com/ragaPriya224/Dru24Batch1/blob/master/multithreading/DeadLock.mp4
Note : 
If main thread calls join() on child thread object and child thread called join() on main 
thread object then both threads will wait for each other forever and the program will be 
hanged(like deadlock if a Thread class join() method on the same thread itself then the 
program will be hanged ).  
Example : 
 
class ThreadDemo { 
public static void main() throws InterruptedException { 
Thread.currentThread().join(); 
      ---------------   -------- 
        main              main 
} 
 
}


Sleep() method: 
----------------
If a Thread don't want to perform any operation for a particular amount of time then 
we should go for sleep() method. 

Interrupting a Thread: 
----------------------
 
How a Thread can interrupt another thread ?  
If a Thread can interrupt a sleeping or waiting Thread by using interrupt()(break off) 
method of Thread class.  
public void interrupt(); 

if interrupt() - on waiting/sleeping thread - it will be interrupted immediately
if interrupt() - on a normal thread - it will wait, until the thread enters waiting/sleeping state 
				      once thread enters waiting/sleeping state , then it will be interrupted immediately
				      thread never enters waiting/sleeping state, interrupt() call is wasted :( 

-----------------------------
Synchronization 
1. Synchronized is the keyword applicable for methods and blocks but not for 
classes and variables. 
2. If a method or block declared as the synchronized then at a time only one 
Thread is allow to execute that method or block on the given object. 
3. The main advantage of synchronized keyword is we can resolve date 
inconsistency problems. 
4. But the main disadvantage of synchronized keyword is it increases waiting time 
of the Thread and effects performance of the system. 
5. Hence if there is no specific requirement then never recommended to use 
synchronized keyword. 
6. Internally synchronization concept is implemented by using lock concept. 
7. Every object in java has a unique lock. Whenever we are using synchronized 
keyword then only lock concept will come into the picture. 
8. If a Thread wants to execute any synchronized method on the given object 1st it 
has to get the lock of that object. Once a Thread got the lock of that object then 
it's allow to execute any synchronized method on that object. If the synchronized 
method execution completes then automatically Thread releases lock. 
9. While a Thread executing any synchronized method the remaining Threads are 
not allowed execute any synchronized method on that object simultaneously. But 
remaining Threads are allowed to execute any non-synchronized method 
simultaneously.

If we are not declaring m1() method as synchronized then both Threads will be 
executed simultaneously and we will get irregular output.


Case study: 
Case 1: 
Display d1=new Display(); 
Display d2=new Display(); 
MyThread t1=new MyThread(d1,"dhoni"); 
MyThread t2=new MyThread(d2,"yuvaraj"); 
t1.start(); 
t2.start();

 
Even though we declared wish() method as synchronized but we will get irregular 
output in this case, because both Threads are operating on different objects.  
Conclusion : If multiple threads are operating on multiple objects then there is no 
impact of Syncronization. 
If multiple threads are operating on same java objects then syncronized concept is 
required(applicable). 


Class level lock: 
------------------
1. Every class in java has a unique lock. If a Thread wants to execute a static 
synchronized method then it required class level lock. 
2. Once a Thread got class level lock then it is allow to execute any static 
synchronized method of that class. 
3. While a Thread executing any static synchronized method the remaining 
Threads are not allow to execute any static synchronized method of that class 
simultaneously. 
4. But remaining Threads are allowed to execute normal synchronized methods, 
normal static methods, and normal instance methods simultaneously. 
5. Class level lock and object lock both are different and there is no relationship 
between these two. 

Synchronized block: 
-------------------
1. If very few lines of the code required synchronization then it's never 
recommended to declare entire method as synchronized we have to enclose those 
few lines of the code with in synchronized block. 
2. The main advantage of synchronized block over synchronized method is it 
reduces waiting time of Thread and improves performance of the system. 

 
Example 1: To get lock of current object we can declare synchronized block as follows. 
If Thread got lock of current object then only it is allowed to execute this block. 
Synchronized(this){}  

Example 2: To get the lock of a particular object 'b' we have to declare a synchronized 
block as follows. 
If thread got lock of 'b' object then only it is allowed to execute this block. 
Synchronized(b){}  

Example 3: To get class level lock we have to declare synchronized block as follows. 
Synchronized(Display.class){}  
If thread got class level lock of Display then only it allowed to execute this block.  


Inter Thread communication (wait(),notify(), notifyAll()): 
-----------------------------------------------------------
 Two Threads can communicate with each other by using wait(), notify() and 
notifyAll() methods. 
 The Thread which is required updation it has to call wait() method on the 
required object then immediately the Thread will entered into waiting state. 
The Thread which is performing updation of object, it is responsible to give 
notification by calling notify() method. 
After getting notification the waiting Thread will get those updations. 

wait(), notify() and notifyAll() methods are available in Object class but not in 
Thread class because Thread can call these methods on any common object. 
 To call wait(), notify() and notifyAll() methods compulsory the current Thread 
should be owner of that object  
i.e., current Thread should has lock of that object 
i.e., current Thread should be in synchronized area. Hence we can call wait(), 
notify() and notifyAll() methods only from synchronized area otherwise we will 
get runtime exception saying IllegalMonitorStateException. 
 Once a Thread calls wait() method on the given object 1st it releases the lock of 
that object immediately and entered into waiting state. 
 Once a Thread calls notify() (or) notifyAll() methods it releases the lock of that 
object but may not immediately. 
 Except these (wait(),notify(),notifyAll()) methods there is no other place(method) 
where the lock release will be happen. 


Producer consumer problem: 
 Producer(producer Thread) will produce the items to the queue and 
consumer(consumer thread) will consume the items from the queue. If the queue 
is empty then consumer has to call wait() method on the queue object then it will 
entered into waiting state. 
 After producing the items producer Thread call notify() method on the queue to 
give notification so that consumer Thread will get that notification and consume 
items.



Notify vs notifyAll(): 
 We can use notify() method to give notification for only one Thread. If multiple 
Threads are waiting then only one Thread will get the chance and remaining 
Threads has to wait for further notification. But which Thread will be 
notify(inform) we can't expect exactly it depends on JVM. 
 We can use notifyAll() method to give the notification for all waiting Threads. All 
waiting Threads will be notified and will be executed one by one, because they 
are required lock


Dead lock: 
 If 2 Threads are waiting for each other forever(without end) such type of 
situation(infinite waiting) is called dead lock. 
 There are no resolution techniques for dead lock but several 
prevention(avoidance) techniques are possible. 
 Synchronized keyword is the cause for deadlock hence whenever we are using 
synchronized keyword we have to take special care. 


Daemon Threads: 
The Threads which are executing in the background are called daemon Threads. 
The main objective of daemon Threads is to provide support for non-daemon Threads 
like main Thread. 
Example:  
Garbage collector  
When ever the program runs with low memory the JVM will execute Garbage Collector 
to provide free memory. So that the main Thread can continue it's execution.  
 We can check whether the Thread is daemon or not by using isDaemon() method 
of Thread class.  
public final boolean isDaemon();  
 We can change daemon nature of a Thread by using setDaemon () method.  
public final void setDaemon(boolean b);  
 But we can change daemon nature before starting Thread only. That is after 
starting the Thread if we are trying to change the daemon nature we will get R.E 
saying IllegalThreadStateException. 
 Default Nature : Main Thread is always non daemon and we can't change its 
daemon nature because it's already started at the beginning only. 
 Main Thread is always non daemon and for the remaining Threads daemon 
nature will be inheriting from parent to child that is if the parent is daemon child 
is also daemon and if the parent is non daemon then child is also non daemon. 
 Whenever the last non daemon Thread terminates automatically all daemon 
Threads will be terminated.


Deadlock vs Starvation: 
----------------------------
 A long waiting of a Thread which never ends is called deadlock. 
 A long waiting of a Thread which ends at certain point is called starvation. 
 A low priority Thread has to wait until completing all high priority Threads. 
 This long waiting of Thread which ends at certain point is called starvation. 

How to kill a Thread in the middle of the line? 
----------------------------------------------
 We can call stop() method to stop a Thread in the middle then it will be entered 
into dead state immediately. 
public final void stop();  
 stop() method has been deprecated and hence not recommended to use. 

suspend and resume methods: 
------------------------------
 A Thread can suspend another Thread by using suspend() method then that 
Thread will be paused temporarily. 
 A Thread can resume a suspended Thread by using resume() method then 
suspended Thread will continue its execution.  
1. public final void suspend(); 
2. public final void resume(); 
 Both methods are deprecated and not recommended to use. 

RACE condition: 
------------------
Executing multiple Threads simultaneously and causing data inconsistency problems is 
nothing but Race condition 
we can resolve race condition by using synchronized keyword. 

ThreadGroup: 
------------
Based on functionality we can group threads as a single unit which is nothing but 
ThreadGroup. 
 
ThreadGroup provides a convenient way to perform common operations for all threads 
belongs to a perticular group.  
We can create a ThreadGroup by using the following constructors  
ThreadGroup g=new ThreadGroup(String gName);  

 
We can attach a Thread to the ThreadGroup by using the following constructor of 
Thread class 
Thread t=new Thread(ThreadGroup g, String name);  
ThreadGroup g=new ThreadGroup("Printing Threads"); 
MyThread t1=new MyThread(g,"Header Printing"); 
MyThread t2=new MyThread(g,"Footer Printing"); 
MyThread t3=new MyThread(g,"Body Printing");


GreenThread Model 
------------------
The threads which are managed completely by JVM without taking support for 
underlying OS, such type of threads are called Green Threads.




